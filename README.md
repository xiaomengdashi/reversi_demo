### 执行
```asm
mkdir build 
cd build
cmake .. && make
cd bin
./reversi ../../file/init5.txt
./inuttest
```


### 要求：
    a) 找到所有可以落黑棋的地方
    b)  在找到可落子的地方后，翻转被夹住的白棋

### 设计思路
    1. 首先判断点(x,y)是否可以落子，从逆时针方向，依次判断该方向是否存在白棋，并且之后出现黑棋。
    如果该方向存在白棋，并且最后出现黑棋，说明该点可以落子。并通过direction_[x][y][]记录该点的各个方向是否可以落子。
    如：direction_[x][y][0]=1表示从点(x,y)右方向判断，该点可以落子。
    
    2. 循环遍历棋盘上的空点，依次判断这些点是否能下棋。并将这些点(x,y)转换成字符串"xy",并插入到可以落子的集合can_reverse_point_set中。
     
    3. 根据direction_[x][y][]将点(x,y)的各个方向依次翻转夹住的白棋，并落子。

    4. 循环遍历can_reverse_point_set_，输出所有的翻转棋盘。

### 亮点
    1. 将落子点的判断方向存储到direction_，再翻转棋盘的时候根据direction_翻转对应的方向。
    2. 将落子点存储到set中，避免重复。

### 待改进

    1. 判断落子的8个方向的函数和翻转棋盘函数存在较多的重复代码，考虑采用数组的形式优化.
    根据逆时针方向，tx,ty的变化可以表示为
    横坐标方向为dx[8] = [0,-1,-1,-1,0,1,1,1]，纵向为dy[8] = [1,-1,0,1,-1,-1,0,1]。
    采用dx[i]和dy[i]替换。